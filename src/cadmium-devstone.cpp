#include <iostream>
#include <chrono>
#include <fstream>
#include <regex>
#include <boost/program_options.hpp>
#include <cadmium/engine/pdevs_runner.hpp>

using namespace std;
namespace po=boost::program_options;
using hclock=chrono::high_resolution_clock;

// In the case of Cadmium we generate a sourceafile for the model requested in parameters
// This model will need to be compiled and run by the user
// Reason is to avoid adding the overhead of constructing a recursive model at the time of evaluation,
// which is artificial and does not match common usage scenario for the simulator.

//For reference, we want to generate the file cadmium-ref-LI.cpp when parameters are W=3, D=3

const string header = R"/(
//THIS IS AN AUTOGENERATED MODEL
/**
 * Copyright (c) 2017, Damian Vicino
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <chrono>
#include <cadmium/modeling/coupled_model.hpp>
#include <cadmium/modeling/ports.hpp>
#include <cadmium/engine/pdevs_runner.hpp>
#include "cadmium-devstone-atomic.hpp"
#include "cadmium-event-reader.hpp"

// Ports for coupled models, we use the same in every level
struct coupled_in_port : public cadmium::in_port<int>{};
struct coupled_out_port : public cadmium::out_port<int>{};
using coupled_in_ports = std::tuple<coupled_in_port>;
using coupled_out_ports = std::tuple<coupled_out_port>;

//Devstones have no Internal coupling
using ics=std::tuple<>;
)/";

const string level_0 = R"/(
//Level 0 has always a single model
template<typename TIME>
struct devstone_atomic_L0_0 : configured_atomic_devstone<TIME>{};

)/";

ostream& configure_atomic(int internal_cycles, int external_cycles, int period, ostream& os){
    os << R"/(
//A configured version of the devstone atomic, we use same configuration in every atomic.
template<typename TIME>
struct configured_atomic_devstone : devstone_atomic<TIME>{
    configured_atomic_devstone(){
        devstone_atomic<TIME>::period = )/" << period << R"/(;
        devstone_atomic<TIME>::external_cycles = )/" << external_cycles << R"/(;
        devstone_atomic<TIME>::internal_cycles = )/" << internal_cycles << R"/(;
    }
};

)/";
    return os;
}

ostream& generate_coupled_model(int level, int width, ostream &os) {
    os << R"/(
//coupled
using L)/" << level << R"/(_submodels=cadmium::modeling::models_tuple<)/";
    for (int atom=0; atom < width; atom++){
        os  << "devstone_atomic_L" << level - 1 << "_" << atom << ", ";
    }
    os << "L" << level -1 << "_coupled>;" << endl;
    string haystack_init = R"/(
using L<<LEVEL>>_eics=std::tuple<
    cadmium::modeling::EIC<coupled_in_port, L<<PRELEVEL>>_coupled, coupled_in_port>)/";
     string haystack_end = R"/(
>;
using L<<LEVEL>>_eocs=std::tuple<
    cadmium::modeling::EOC<L<<PRELEVEL>>_coupled,coupled_out_port, coupled_out_port>
>;
template<typename TIME>
using L<<LEVEL>>_coupled=cadmium::modeling::coupled_model<TIME, coupled_in_ports, coupled_out_ports, L<<LEVEL>>_submodels, L<<LEVEL>>_eics, L<<LEVEL>>_eocs, ics>;
)/";
    os << regex_replace(
                        regex_replace( haystack_init, regex(R"/(<<LEVEL>>)/"), to_string(level)),
                        regex(R"/(<<PRELEVEL>>)/"),
                        to_string(level-1)
                        );
    for (int atom=0; atom < width; atom++){
        os << R"/(,
    cadmium::modeling::EIC<coupled_in_port, devstone_atomic_L)/" << level-1 << "_" << atom <<R"/(, devstone_atomic_defs::in>)/";
    }
    os << regex_replace(
                        regex_replace( haystack_end, regex(R"/(<<LEVEL>>)/"), to_string(level)),
                        regex(R"/(<<PRELEVEL>>)/"),
                        to_string(level-1)
                        );
    return os;
}
        
ostream& generate_level(int level, int width, ostream& os){
    if (level == 0) throw runtime_error("level 0 model is generated by another function");
    os <<
R"/(//Level )/" << level << R"/(
//atomics)/";
    for (int atom=0; atom < width; atom++){
        os << R"/(
template<typename TIME>
struct devstone_atomic_L)/" << level << "_" << atom << R"/( : configured_atomic_devstone<TIME>{};)/";
    }
    if (level == 1){ //only 1 submodel 0_0
    os <<
R"/(
//coupled
using L1_submodels=cadmium::modeling::models_tuple<devstone_atomic_L0_0>;
using L1_eics=std::tuple<
    cadmium::modeling::EIC<coupled_in_port, devstone_atomic_L0_0, devstone_atomic_defs::in>
>;
using L1_eocs=std::tuple<
    cadmium::modeling::EOC<devstone_atomic_L0_0, devstone_atomic_defs::out, coupled_out_port>
>;
template<typename TIME>
using L1_coupled=cadmium::modeling::coupled_model<TIME, coupled_in_ports, coupled_out_ports, L1_submodels, L1_eics, L1_eocs, ics>;
)/";
    } else {
        generate_coupled_model(level, width, os);
    }
    return os;
}
        
ostream& generate_top_models(int depth, int width, ostream& os){
    //creating the last coupled model
    os << R"/(
//Level )/" << depth << " has no atomics because it is the last level";
    generate_coupled_model(depth, width, os);
    //creating the top model coupling the last coupled model and the input of external events
   os << R"/(
//TOP model conecting a generator of events to the input
using TOP_coupled_in_ports=std::tuple<>;
using TOP_coupled_out_ports=std::tuple<>;
using TOP_submodels=cadmium::modeling::models_tuple<devstone_event_reader, L)/" << depth << R"/(_coupled>;
using TOP_eics=std::tuple<>;
using TOP_eocs=std::tuple<>;
using TOP_ics=std::tuple<
cadmium::modeling::IC<devstone_event_reader, devstone_event_reader_defs::out, L)/" << depth << R"/(_coupled, coupled_in_port>
>;
template<typename TIME>
using TOP_coupled=cadmium::modeling::coupled_model<TIME, TOP_coupled_in_ports, TOP_coupled_out_ports, TOP_submodels, TOP_eics, TOP_eocs, TOP_ics>;
)/";
    return os;
}

ostream& generate_main(bool log_all, ostream& os){
    if (log_all){
        os << R"/("
        //LOG state changes TO COUT
        using namespace cadmium::logger;
        using info=logger<logger_info, verbatim_formatter, cout_sink_provider>;
        using debug=logger<logger_debug, verbatim_formatter, cout_sink_provider>;
        using state=logger<logger_state, verbatim_formatter, cout_sink_provider>;
        using log_messages=logger<logger_messages, verbatim_formatter, cout_sink_provider>;
        using routing=logger<logger_message_routing, verbatim_formatter, cout_sink_provider>;
        using global_time=logger<logger_global_time, verbatim_formatter, cout_sink_provider>;
        using local_time=logger<logger_local_time, verbatim_formatter, cout_sink_provider>;
        using log_all=multilogger<info, debug, state, log_messages, routing, global_time, local_time>;
)/";
    }
    os << R"/(
using hclock=std::chrono::high_resolution_clock; //for measuring execution time

int main(){
    auto start = hclock::now(); //to measure simulation execution time
    
)/";
    if ( log_all ) {
        os << R"/(cadmium::engine::runner<float, TOP_coupled, log_all> r{0.0};
)/";
    } else { //default logger
        os << R"/(cadmium::engine::runner<float, TOP_coupled, cadmium::logger::not_logger> r{0.0};
        )/";
    }
    os << R"/(
    r.runUntil(std::numeric_limits<float>::infinity());
    
    auto elapsed = std::chrono::duration_cast<std::chrono::duration<double, std::ratio<1>>>
    (hclock::now() - start).count();
    std::cout << "Simulation took:" << elapsed << "sec" << std::endl;
    return 0;
}
)/";
    return os;
}
        
int main(int argc, char* argv[]){
    auto start = hclock::now();

    // Declare the supported options.
    po::options_description desc("Allowed options");
    desc.add_options()
    ("help", "produce help message")
    ("kind", po::value<string>()->required(), "set kind of devstone: LI, HI or HO")
    ("width", po::value<int>()->required(), "set width of the DEVStone: integer value")
    ("depth", po::value<int>()->required(), "set depth of the DEVStone: integer value")
    ("int-cycles", po::value<int>()->required(), "set the Dhrystone cycles to expend in internal transtions: integer value")
    ("ext-cycles", po::value<int>()->required(), "set the Dhrystone cycles to expend in external transtions: integer value")
    ("event-list", po::value<string>()->required(), "set the file to read the events. The format is 2 ints per line meaning time->msg")
    ("time-advance", po::value<int>()->default_value(1), "set the time expend in external transtions by the Dhrystone in miliseconds: integer value")
    ("output", po::value<string>()->required(), "set the name of the file to save the generated model")
    ("logger", po::value<string>()->default_value("default"), "set the logger to use. Options: all, default")
    ;
    
    po::variables_map vm;
    try {
        po::store(po::parse_command_line(argc, argv, desc), vm);
        po::notify(vm);
    } catch ( boost::program_options::required_option be ){
        if (vm.count("help")) {
            cout << desc << "\n";
            return 0;
        } else {
            cout << be.what() << endl;
            cout << endl;
            cout << "for mode information run: " << argv[0] << " --help" << endl;
            return 1;
        }
    }
    string kind = vm["kind"].as<string>();
    if (kind.compare("LI") != 0  && kind.compare("HI") != 0 && kind.compare("HO") != 0) {
        cout << "The kind needs to be LI, HI or HO and received value was: " << kind;
        cout << endl;
        cout << "for mode information run: " << argv[0] << " --help" << endl;
        return 1;
    }
    
    {
        std::ifstream f(vm["event-list"].as<string>().c_str());
        if(!f.is_open()){
            cout << "File for events: " << vm["event-list"].as<string>() << " is not accesible." << endl;
            cout << endl;
            cout << "for mode information run: " << argv[0] << " --help" << endl;
        }
    }
    
    {
        std::ofstream f(vm["output"].as<string>().c_str());
        if(!f.is_open()){
            cout << "File for model: " << vm["output"].as<string>() << " is not accesible." << endl;
            cout << endl;
            cout << "for mode information run: " << argv[0] << " --help" << endl;
        }
    }
    
    int width = vm["width"].as<int>();
    int depth = vm["depth"].as<int>();
    int int_cycles = vm["int-cycles"].as<int>();
    int ext_cycles = vm["ext-cycles"].as<int>();
    int time_advance = vm["time-advance"].as<int>();
    string event_list = vm["event-list"].as<string>();
    string output = vm["output"].as<string>();
    bool log_all = (vm["logger"].as<string>() == "default"?false:true);
    //finished processing input
    
    auto processed_parameters = hclock::now();

    //create models for LI kind
    int models_quantity = (width - 1) * (depth - 1) + 1;
    
    {
        std::ofstream ofs(output);
        if (!ofs.good()) {
            throw runtime_error("Couldn't open file to output generated model");
        }
        ofs << header;
        configure_atomic(int_cycles, ext_cycles, time_advance, ofs);
        ofs << "//This model is " << kind << " devstone W=" << width <<", D=" << depth;
        ofs << level_0;
        for (int l=1; l < depth; l++) {
            generate_level(l, width, ofs);
        }
        generate_top_models(depth, width, ofs);
        generate_main(log_all, ofs);
    }
    
    auto model_generated = hclock::now();

    cout << "Simulation with params: ";

    cout << "kind: LI ";
    cout << "width: " << width << " ";
    cout << "depth: " << depth << " ";
    cout << "external: " << ext_cycles << " ";
    cout << "internal: " << int_cycles << " ";
    cout << "logger: " << (log_all?"ALL":"default");
    cout << endl;

    cout << "theory atomic models created: " << models_quantity << std::endl;
    cout << "time processing arguments: " << chrono::duration_cast<chrono::duration<double, ratio<1>>>( processed_parameters - start).count() << endl;
    cout << "time constructing the models: " << chrono::duration_cast<chrono::duration<double, ratio<1>>>( model_generated - processed_parameters).count() << endl;
    cout << "total time: " << chrono::duration_cast<chrono::duration<double, ratio<1>>>( model_generated - start).count() << endl;
    return 0;
}
