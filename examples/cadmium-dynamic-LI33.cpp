
//THIS IS A REF FOR AN AUTOGENERATED MODEL
/**
 * Copyright (c) 2019, Juan Lanuza
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <chrono>
#include "../src/cadmium-devstone-atomic.hpp"
#include "../src/cadmium-event-reader.hpp"

#include <cadmium/modeling/coupled_model.hpp>
#include <cadmium/modeling/ports.hpp>
#include <cadmium/modeling/dynamic_model_translator.hpp>
#include <cadmium/concept/coupled_model_assert.hpp>
#include <cadmium/modeling/dynamic_coupled.hpp>
#include <cadmium/modeling/dynamic_atomic.hpp>
#include <cadmium/engine/pdevs_dynamic_runner.hpp>
#include <cadmium/logger/tuple_to_ostream.hpp>
#include <cadmium/logger/common_loggers.hpp>

using TIME = float;

// Ports for coupled models, we use the same in every level
struct coupled_in_port : public cadmium::in_port<int>{};
struct coupled_out_port : public cadmium::out_port<int>{};
cadmium::dynamic::modeling::Ports coupled_in_ports = {typeid(coupled_in_port)};
cadmium::dynamic::modeling::Ports coupled_out_ports = {typeid(coupled_out_port)};

//Devstones have no Internal coupling
cadmium::dynamic::modeling::ICs ics = {};

//A configured version of the devstone atomic, we use same configuration in every atomic.
template<typename T>
struct configured_atomic_devstone : devstone_atomic<T>{
    configured_atomic_devstone(){
        devstone_atomic<T>::period = 1;
        devstone_atomic<T>::external_cycles = 100;
        devstone_atomic<T>::internal_cycles = 100;
    }
};

//This model is LI devstone W=3, D=3
//Level 0 has always a single model
std::shared_ptr<cadmium::dynamic::modeling::model> devstone_atomic_L0_0 = cadmium::dynamic::translate::make_dynamic_atomic_model<configured_atomic_devstone, TIME>("devstone_atomic_L0_0");
//Level 1
//atomics
std::shared_ptr<cadmium::dynamic::modeling::model> devstone_atomic_L1_0 = cadmium::dynamic::translate::make_dynamic_atomic_model<configured_atomic_devstone, TIME>("devstone_atomic_L1_0");
std::shared_ptr<cadmium::dynamic::modeling::model> devstone_atomic_L1_1 = cadmium::dynamic::translate::make_dynamic_atomic_model<configured_atomic_devstone, TIME>("devstone_atomic_L1_1");
std::shared_ptr<cadmium::dynamic::modeling::model> devstone_atomic_L1_2 = cadmium::dynamic::translate::make_dynamic_atomic_model<configured_atomic_devstone, TIME>("devstone_atomic_L1_2");

//coupled
cadmium::dynamic::modeling::Models L1_submodels = {devstone_atomic_L0_0};
cadmium::dynamic::modeling::EICs L1_eics = {
  cadmium::dynamic::translate::make_EIC<coupled_in_port, devstone_atomic_defs::in>("devstone_atomic_L0_0")
};
cadmium::dynamic::modeling::EOCs L1_eocs = {
  cadmium::dynamic::translate::make_EOC<devstone_atomic_defs::out,coupled_out_port>("devstone_atomic_L0_0")
};
std::shared_ptr<cadmium::dynamic::modeling::coupled<TIME>> L1_coupled = std::make_shared<cadmium::dynamic::modeling::coupled<TIME>>(
 "L1_coupled",
 L1_submodels,
 coupled_in_ports,
 coupled_out_ports,
 L1_eics,
 L1_eocs,
 ics
);

//Level 2
//atomics
std::shared_ptr<cadmium::dynamic::modeling::model> devstone_atomic_L2_0 = cadmium::dynamic::translate::make_dynamic_atomic_model<configured_atomic_devstone, TIME>("devstone_atomic_L2_0");
std::shared_ptr<cadmium::dynamic::modeling::model> devstone_atomic_L2_1 = cadmium::dynamic::translate::make_dynamic_atomic_model<configured_atomic_devstone, TIME>("devstone_atomic_L2_1");
std::shared_ptr<cadmium::dynamic::modeling::model> devstone_atomic_L2_2 = cadmium::dynamic::translate::make_dynamic_atomic_model<configured_atomic_devstone, TIME>("devstone_atomic_L2_2");

//coupled
cadmium::dynamic::modeling::Models L2_submodels = {devstone_atomic_L1_0, devstone_atomic_L1_1, devstone_atomic_L1_2, L1_coupled};
cadmium::dynamic::modeling::EICs L2_eics = {
  cadmium::dynamic::translate::make_EIC<coupled_in_port, coupled_in_port>("L1_coupled"),
  cadmium::dynamic::translate::make_EIC<coupled_in_port, devstone_atomic_defs::in>("devstone_atomic_L1_0"),
  cadmium::dynamic::translate::make_EIC<coupled_in_port, devstone_atomic_defs::in>("devstone_atomic_L1_1"),
  cadmium::dynamic::translate::make_EIC<coupled_in_port, devstone_atomic_defs::in>("devstone_atomic_L1_2")
};
cadmium::dynamic::modeling::EOCs L2_eocs = {
  cadmium::dynamic::translate::make_EOC<coupled_out_port, coupled_out_port>("L1_coupled")
};
std::shared_ptr<cadmium::dynamic::modeling::coupled<TIME>> L2_coupled = std::make_shared<cadmium::dynamic::modeling::coupled<TIME>>(
 "L2_coupled",
 L2_submodels,
 coupled_in_ports,
 coupled_out_ports,
 L2_eics,
 L2_eocs,
 ics
);

//Level 3 has no atomics because it is the last level
//coupled
cadmium::dynamic::modeling::Models L3_submodels = {devstone_atomic_L2_0, devstone_atomic_L2_1, devstone_atomic_L2_2, L2_coupled};
cadmium::dynamic::modeling::EICs L3_eics = {
  cadmium::dynamic::translate::make_EIC<coupled_in_port, coupled_in_port>("L2_coupled"),
  cadmium::dynamic::translate::make_EIC<coupled_in_port, devstone_atomic_defs::in>("devstone_atomic_L2_0"),
  cadmium::dynamic::translate::make_EIC<coupled_in_port, devstone_atomic_defs::in>("devstone_atomic_L2_1"),
  cadmium::dynamic::translate::make_EIC<coupled_in_port, devstone_atomic_defs::in>("devstone_atomic_L2_2")
};
cadmium::dynamic::modeling::EOCs L3_eocs = {
  cadmium::dynamic::translate::make_EOC<coupled_out_port, coupled_out_port>("L2_coupled")
};
std::shared_ptr<cadmium::dynamic::modeling::coupled<TIME>> L3_coupled = std::make_shared<cadmium::dynamic::modeling::coupled<TIME>>(
 "L3_coupled",
 L3_submodels,
 coupled_in_ports,
 coupled_out_ports,
 L3_eics,
 L3_eocs,
 ics
);

//Create instance of devstone_event_reader
std::shared_ptr<cadmium::dynamic::modeling::model> devstone_event_reader1 = cadmium::dynamic::translate::make_dynamic_atomic_model<devstone_event_reader, TIME>("devstone_event_reader1");


//TOP model conecting a generator of events to the input
cadmium::dynamic::modeling::Ports TOP_coupled_in_ports = {};
cadmium::dynamic::modeling::Ports TOP_coupled_out_ports = {};
cadmium::dynamic::modeling::Models TOP_submodels = {devstone_event_reader1, L3_coupled};
cadmium::dynamic::modeling::EICs TOP_eics = {};
cadmium::dynamic::modeling::EOCs TOP_eocs = {};
cadmium::dynamic::modeling::ICs TOP_ics = {
    cadmium::dynamic::translate::make_IC<devstone_event_reader_defs::out,coupled_in_port>("devstone_event_reader1","L3_coupled")
};
std::shared_ptr<cadmium::dynamic::modeling::coupled<TIME>> TOP_coupled = std::make_shared<cadmium::dynamic::modeling::coupled<TIME>>(
 "TOP_coupled",
 TOP_submodels,
 TOP_coupled_in_ports,
 TOP_coupled_out_ports,
 TOP_eics,
 TOP_eocs,
 TOP_ics
);

using hclock=std::chrono::high_resolution_clock; //for measuring execution time

int main(){
    auto start = hclock::now(); //to measure simulation execution time

    cadmium::dynamic::engine::runner<TIME, cadmium::logger::not_logger> r(TOP_coupled, 0.0);
    r.run_until_passivate();

    auto elapsed = std::chrono::duration_cast<std::chrono::duration<double, std::ratio<1>>>
    (hclock::now() - start).count();
    std::cout << "Simulation took:" << elapsed << "sec" << std::endl;
    return 0;
}
